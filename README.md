# AI Generated issue management system

Will AI replace software developers? Can AI already create a complete web application?
This is an experiment to see if AI can write a complete web application for us.

Unless you have checked out one of the branches, you are looking at a repository
without any code in it. There is only a README.md file and a `specifications` folder. The specifications folder contains the specifications for a non-trivial, but not overly complex web application, an issue management system. It describes usecases and detailed specifications of every page. Please note that the specifications were generated using AI and are far from perfect.

Normally a programmer would write the code and GitHub copilot helps out. In this experiment we will use GitHub copilot chat to write the code we tell it to, essentially making this copilot an autopilot ðŸ¤¯.

## Phase 1: Technical documentation

Trying to create big pieces of a web application in one prompt will not work. So in this experiment we break down the application into small files, 
where each file is generated by a prompt which contains a handful of other files. The first step may sound boring: technical documentation. This experiment uses mongodb, so let's start by describing the mongodb documents.
A formal mongodb json schema is an option, but if we want devops engineers to be able to query the database, documentation in a natural language would be preferable. Natural language also works very well for AI, so let's do that.

### Comment document structure

Let's start with the describing the mongodb document used for comments.
We proceed as follows: We start a new chat window with **copilot chat** and copy-paste the contents of all files that are relevant. In this case we add the contents of `specifications/readme.md` and `specifications/pages/issue-details.md`. After this we add the following prompt:

```markdown
You are writing technical documentation for our web application to use as reference. You create short concise markdown documents that define how each document in mongodb is structured. You define fields, relations and custom indices. You use links to other documents like this: [user](user.md), [issue](issue.md), etcetera.

Create the documentation for comment documents.
```

And voila, copilot chat creates a nice document for us that we can store under `docs/database/comment.md`, it is a nice reference document for humans, but it is also perfect for our next prompts.

````markdown
# Comment Document

The comment document is used to store comments made by users on issues. Each comment is associated with a specific issue and user.

## Fields

- **_id**: ObjectId - The unique identifier for the comment.
- **issueId**: Integer - The id of the issue that the comment is associated with. This is a reference to the [issue](issue.md) document.
- **userId**: ObjectId - The id of the user who made the comment. This is a reference to the [user](user.md) document.
- **text**: String - The text of the comment. This field has a maximum length of 500 characters.
- **timestamp**: Date - The date and time when the comment was posted.

## Relations

- **issue**: Each comment is associated with one issue. The `issueId` field is a reference to the [issue](issue.md) document.
- **user**: Each comment is associated with one user. The `userId` field is a reference to the [user](user.md) document.

## Indices

- **issueId**: An index is created on the `issueId` field to quickly fetch all comments associated with a specific issue.
- **userId**: An index is created on the `userId` field to quickly fetch all comments made by a specific user.

## Example

```json
{
    "_id": ObjectId("60d5ec9af682fbd12a892fe0"),
    "issueId": 1,
    "userId": ObjectId("60d5ec9af682fbd12a892fd7"),
    "text": "This is a comment on the issue.",
    "timestamp": ISODate("2021-06-25T12:00:00Z")
}
```
````

### Issue document structure

The issue document is next. We use basically the same prompt as comment, but
we now also provide the comment document we just created, so copilot chat knows
how the relation between issues and comments is structured. 
We also want this document to describe how to increment the id.
So once more we start a clean chat window, paste the files `specifications/readme.md`, `specifications/pages/issue-details.md` and `docs/database/comment` add the prompt:

```markdown
You are writing technical documentation for our web application to use as reference. You create short concise markdown documents that define how each document in mongodb is structured. You define fields, relations and custom indices. You use links to other documents like this: [user](user.md), [issue](issue.md), etcetera. Do not use nested markdown snippets.

Create the documentation for issues.
```

The response is again beautiful. We save the response to `docs/database/issue.md`.

````markdown
# Issue Document

The issue document is used to store issues reported by users. Each issue is associated with a specific user and can have multiple comments.

## Fields

- **_id**: Integer - The unique identifier for the issue. This field auto increments and is never reused.
- **title**: String - The title of the issue. This field has a maximum length of 100 characters.
- **description**: String - The description of the issue.
- **status**: String - The status of the issue. This field can have one of the following values: 'Open', 'In Progress', 'Closed'.
- **creatorId**: ObjectId - The id of the user who created the issue. This is a reference to the [user](user.md) document.
- **assigneeId**: ObjectId - The id of the user who is assigned to the issue. This is a reference to the [user](user.md) document.

## Relations

- **creator**: Each issue is associated with one user as the creator. The `creatorId` field is a reference to the [user](user.md) document.
- **assignee**: Each issue can be associated with one user as the assignee. The `assigneeId` field is a reference to the [user](user.md) document.
- **comments**: Each issue can have multiple comments. The relation is established via the `issueId` field in the [comment](comment.md) document.

## Indices

- **_id**: An index is created on the `_id` field to quickly fetch issues by their id.
- **creatorId**: An index is created on the `creatorId` field to quickly fetch all issues created by a specific user.
- **assigneeId**: An index is created on the `assigneeId` field to quickly fetch all issues assigned to a specific user.

## Example

```json
{
    "_id": 1,
    "title": "Issue title",
    "description": "This is a description of the issue.",
    "status": "Open",
    "creatorId": ObjectId("60d5ec9af682fbd12a892fd7"),
    "assigneeId": ObjectId("60d5ec9af682fbd12a892fd8")
}
```
````

I hoped the document would also include instructions on how to increment the id. My first attempt was to add `include instructions on how to determine the next _id` to the prompt. This worked perfectly a week ago in an earlier attempt, 
but somehow today it came up with a naive implementation of taking the maximum id and adding 1. This is a bad idea, as it leads to duplicate ids in race conditions and reuse of ids of deleted issues. This made me realize that I should stick to the plilosophy of splitting up
everything into small files. Therefore I had copilot chat create a separate document for the issue-id using the following prompt:
    
````markdown
You are writing technical documentation for our web application to use as reference. You create short concise markdown documents that define how each document in mongodb is structured. You define fields, relations and indices. You use links to other documents like this: [user](user.md), [issue](issue.md), etcetera.

Create the documentation for determining the next _id for issues.
````
This worked perfectly and I saved the response to `docs/database/issue-id.md`. 
Note that response includes sample code, that will make the next steps of code generation easier.
````markdown
# Issue ID Generation

The Issue document in the issue management system uses an integer as its unique identifier (`id`), instead of the typical ObjectId used in MongoDB. This `id` is auto-incremented each time a new issue is created. This ensures that each issue has a unique `id` that is never reused.

## Fields

- **id**: Integer - The unique identifier for the issue. This field is auto-incremented each time a new issue is created.

## Auto-Incrementing the Issue ID

To auto-increment the `id` field, we use a separate MongoDB document to keep track of the last used `id`. This document is in a collection called `counters`.

The `counters` collection has a single document for issue `id` generation:

```json
{
    "_id": "issue_id",
    "seq": 0
}
```

The `seq` field stores the last used `id` for issues. When a new issue is created, we increment the `seq` field and use its value for the `id` of the new issue.

Here is a JavaScript function that performs this operation:

```javascript
async function getNextIssueId() {
    const counter = await db.collection('counters').findOneAndUpdate(
        { _id: 'issue_id' },
        { $inc: { seq: 1 } },
        { returnOriginal: false }
    );
    return counter.value.seq;
}
```

This function uses the `findOneAndUpdate` method to atomically increment the `seq` field and return the updated document. The `returnOriginal: false` option ensures that the updated document is returned, not the original one.

## Indices

- **id**: The `id` field should be indexed for faster lookup of issues.

## Relations

- **None**: The `counters` collection does not have any relations with other collections.

## Example

```json
{
    "_id": "issue_id",
    "seq": 123
}
```

This example represents the `counters` document for issue `id` generation. The `seq` field indicates that the `id` of the next issue to be created will be `124`.
````

### Comment API
We skip the other database documents for now and move on to something else interesting. 
In this experiment we are going to use a REST API between the browser and the server.
Let's create a formal specification this time for the comment API. 
This document will be used by both the server and the client code. 
We start by creating a prompt for the comment API. 
We add the files `specifications/readme.md`, `specifications/pages/issue-details.md` and `docs/database/comment.md` to the chat window and add the following prompt:

````markdown
Create the openapi document describing comment endpoints on /api/comment that these pages need to do queries and updates.
Include details like maximum field lengths and query parameters. 
Use the same names for fields as in the mongodb document, including _id.
````

The response is a beautiful openapi document that we save to `docs/api/comment.yaml`.

````yaml
openapi: 3.0.0
info:
  title: Issue Management API
  version: 1.0.0
paths:
  /api/comment:
    post:
      summary: Create a new comment
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              properties:
                issueId:
                  type: integer
                userId:
                  type: string
                  format: uuid
                text:
                  type: string
                  maxLength: 500
              required:
                - issueId
                - userId
                - text
      responses:
        '201':
          description: Comment created
          content:
            application/json:
              schema:
                type: object
                properties:
                  _id:
                    type: string
                    format: uuid
                  issueId:
                    type: integer
                  userId:
                    type: string
                    format: uuid
                  text:
                    type: string
                  timestamp:
                    type: string
                    format: date-time
    get:
      summary: Get comments for an issue
      parameters:
        - name: issueId
          in: query
          required: true
          schema:
            type: integer
      responses:
        '200':
          description: A list of comments
          content:
            application/json:
              schema:
                type: array
                items:
                  type: object
                  properties:
                    _id:
                      type: string
                      format: uuid
                    issueId:
                      type: integer
                    userId:
                      type: string
                      format: uuid
                    text:
                      type: string
                    timestamp:
                      type: string
                      format: date-time
````
And we now use the same technique for the issue API. 
We add the files `specifications/readme.md`, 
`specifications/pages/issue-list.md`, `specifications/pages/issue-details.md`, `specifications/pages/create-issue.md` 
and `docs/database/issue.md` to the chat window and add the following prompt:

````markdown
Create the openapi document describing issue endpoints on /api/issue that these pages need to do queries and updates. Assume that there are already endpoints for all other documents. Include details like maximum field lengths and query parameters. Also specify which requestBody content properties are required. Use the same names for fields as in the mongodb document. New _ids are always determined by the server and not submitted in create requests.
````

You may have noticed that this prompt was a little harder to get right. This is because github chat kept reusing the `#/components/schemas/Issue` in requests. I guess that had to do with lazyness or something.
We save the final response to `docs/api/issue.yaml` and we can finally move on to produce real code.

````yaml
openapi: 3.0.0
info:
  title: Issue Management API
  version: 1.0.0
paths:
  /api/issue:
    get:
      summary: Get a list of issues
      parameters:
        - name: title
          in: query
          description: Title of the issue
          required: false
          schema:
            type: string
            maxLength: 100
        - name: status
          in: query
          description: Status of the issue
          required: false
          schema:
            type: string
            enum: [Open, In Progress, Closed]
        - name: assigneeId
          in: query
          description: ID of the user assigned to the issue
          required: false
          schema:
            type: string
      responses:
        '200':
          description: A list of issues
          content:
            application/json:
              schema:
                type: array
                items:
                  $ref: '#/components/schemas/Issue'
    post:
      summary: Create a new issue
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/IssueCreate'
      responses:
        '201':
          description: Issue created
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Issue'
  /api/issue/{id}:
    get:
      summary: Get an issue by ID
      parameters:
        - name: id
          in: path
          description: ID of the issue
          required: true
          schema:
            type: integer
      responses:
        '200':
          description: An issue
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Issue'
    put:
      summary: Update an issue
      parameters:
        - name: id
          in: path
          description: ID of the issue
          required: true
          schema:
            type: integer
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/IssueUpdate'
      responses:
        '200':
          description: Issue updated
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Issue'
components:
  schemas:
    Issue:
      type: object
      properties:
        _id:
          type: integer
          description: The unique identifier for the issue
        title:
          type: string
          description: The title of the issue
          maxLength: 100
        description:
          type: string
          description: The description of the issue
        status:
          type: string
          description: The status of the issue
          enum: [Open, In Progress, Closed]
        creatorId:
          type: string
          description: The id of the user who created the issue
        assigneeId:
          type: string
          description: The id of the user who is assigned to the issue
    IssueCreate:
      type: object
      required:
        - title
        - description
      properties:
        title:
          type: string
          description: The title of the issue
          maxLength: 100
        description:
          type: string
          description: The description of the issue
        status:
          type: string
          description: The status of the issue
          enum: [Open, In Progress, Closed]
        creatorId:
          type: string
          description: The id of the user who created the issue
        assigneeId:
          type: string
          description: The id of the user who is assigned to the issue
    IssueUpdate:
      type: object
      properties:
        title:
          type: string
          description: The title of the issue
          maxLength: 100
        description:
          type: string
          description: The description of the issue
        status:
          type: string
          description: The status of the issue
          enum: [Open, In Progress, Closed]
        assigneeId:
          type: string
          description: The id of the user who is assigned to the issue
````

## Phase 2: The server

Before starting to generate the server code, we decide which tools and libraries we want to use.
If you want to experiment with a different stack, you can checkout the `technical-documentation` branch and start from there.
The tools we want to be using are described by the following document that we save to `docs/server.md`.

````markdown
# Server

The server for our web application uses NodeJS with Typescript and express to provide a REST API for the client. The server also connects to a MongoDB database to store and retrieve data using mongoose. We also use express-validator to validate requests. We use Jest to test our application. Passport is the library used to authenticate users using a username and password. Users can also sign up by providing a unique username and password.

Files for the browser are served using express.static. Urls for pages all end with .html (example: login.html, sign-up.html).
We use strict Typescript with es6 module syntax, so use export declarations like `export const` and `export interface`, but do not use `export default`.
Mongoose model files export a model using names like Comment and User along with a typescript interface prefixed with an I like IComment and IUser.
````

The next step we want is a sitemap to describe the folder structure and some main files for our web application. This is done by providing `docs/server` and adding the following prompt:

````markdown
Create a sitemap (a description of the folder structure and some main files for our web application) 
to add to the technical documentation. 
Specify locations for routes, mongoose models, jest testcases, demo data and scripts. 
We use src/server.ts as entry point and public/ for static files to serve.
````

This creates the following friendly response from which we append the markdown section to `docs/server.md` below a `# Sitemap` header and inside a markdown snippet.

````markdown
Here's a sitemap for your application:

```
.
â”œâ”€â”€ src
â”‚   â”œâ”€â”€ server.ts (Entry point for the application)
â”‚   â”œâ”€â”€ routes (Contains all the route handlers)
â”‚   â”‚   â”œâ”€â”€ login.ts
â”‚   â”‚   â”œâ”€â”€ signup.ts
â”‚   â”‚   â””â”€â”€ ...
â”‚   â”œâ”€â”€ models (Contains Mongoose models and corresponding TypeScript interfaces)
â”‚   â”‚   â”œâ”€â”€ User.ts (Exports IUser and User)
â”‚   â”‚   â”œâ”€â”€ Comment.ts (Exports IComment and Comment)
â”‚   â”‚   â””â”€â”€ ...
â”‚   â”œâ”€â”€ middleware (Contains middleware functions)
â”‚   â”‚   â”œâ”€â”€ passport.ts (Passport authentication setup)
â”‚   â”‚   â””â”€â”€ ...
â”‚   â”œâ”€â”€ validators (Contains express-validator validation schemas)
â”‚   â”‚   â”œâ”€â”€ loginValidator.ts
â”‚   â”‚   â”œâ”€â”€ signupValidator.ts
â”‚   â”‚   â””â”€â”€ ...
â”‚   â””â”€â”€ utils (Contains utility functions and scripts)
â”‚       â”œâ”€â”€ demoData.ts (Script to populate the database with demo data)
â”‚       â””â”€â”€ ...
â”œâ”€â”€ public (Contains static files to be served)
â”‚   â”œâ”€â”€ login.html
â”‚   â”œâ”€â”€ signup.html
â”‚   â””â”€â”€ ...
â”œâ”€â”€ tests (Contains Jest test cases)
â”‚   â”œâ”€â”€ login.test.ts
â”‚   â”œâ”€â”€ signup.test.ts
â”‚   â””â”€â”€ ...
â”œâ”€â”€ package.json (Lists package dependencies and scripts)
â”œâ”€â”€ tsconfig.json (TypeScript configuration)
â””â”€â”€ README.md (Project documentation)
```

This is a general structure and may vary based on your specific application needs. The `...` indicates that there may be other files or directories in that location.
````

Creating these folders by hand is a bit time-consuming, so we ask copilot chat to give us the commands to create the folders mentioned in the sitemap. This time we reuse the chat window and continue the conversation with.

````markdown
Give me the commands to create the folders mentioned in the sitemap.
````

The response is a list of commands that we can execute immediately in the terminal using the Insert into terminal button.

```bash
mkdir -p src/routes
mkdir -p src/models
mkdir -p src/middleware
mkdir -p src/validators
mkdir -p src/utils
mkdir public
mkdir tests
```

Note that you must press ENTER in the terminal window to execute the last command. 
Also note that although the response contains bash commands these also work in powershell.

We continue our conversation with copilot chat for the next step.
```
Give me the npm and typescript commands needed to initialize our web application.
```

The response is again very usable, so we press the Insert into terminal button and press enter one more time to execute the last command.

````markdown
Here are the commands you need to initialize your web application:

```bash
# Initialize a new Node.js project
npm init -y

# Install TypeScript
npm install --save-dev typescript

# Initialize a new TypeScript configuration file
npx tsc --init

# Install Express
npm install express

# Install TypeScript types for Node.js and Express
npm install --save-dev @types/node @types/express

# Install other necessary libraries
npm install mongoose express-validator passport
npm install --save-dev @types/mongoose @types/express-validator @types/passport

# Install Jest for testing
npm install --save-dev jest ts-jest @types/jest

# Initialize Jest
npx ts-jest config:init
```

These commands will set up a new Node.js project with TypeScript, Express, Mongoose, express-validator, Passport, and Jest. The `--save-dev` flag is used to save packages for development purposes (like TypeScript and Jest), while the other packages are saved as regular dependencies.
````

We also need a `.gitignore` file, which we do not create ourselves of course, so we use the following prompt and save the result to our project.

````markdown
write a concise .gitignore file for this application
````

Now we can finally create the first bit of code that actually runs. We start a new chat window, copy-paste `docs/server.md` and add the following prompt:

````markdown
Create the content of src/server.ts with the specified authentication, middlewares, static file serving and a placeholder where to add routes later.
````

The response is a good starting point that we can save to `src/server.ts`.

````typescript
import express from 'express';
import mongoose from 'mongoose';
import passport from 'passport';
import { json, urlencoded } from 'body-parser';
import path from 'path';

// Import your passport configuration
import './middleware/passport';

const app = express();

// Connect to MongoDB
mongoose.connect('mongodb://localhost:27017/your-db-name', { useNewUrlParser: true, useUnifiedTopology: true })
  .then(() => console.log('MongoDB connected'))
  .catch(err => console.log(err));

// Middleware setup
app.use(json());
app.use(urlencoded({ extended: false }));
app.use(passport.initialize());

// Static file serving
app.use(express.static(path.join(__dirname, '../public')));

// Placeholder for routes
// TODO: Import and use your routes here

// Start the server
const port = process.env.PORT || 3000;
app.listen(port, () => console.log(`Server is running on port ${port}`));
````

The Typescript compiler immediately notices compile errors, `useNewUrlParser: true, useUnifiedTopology: true` are not recognized.
These options were for an older version of mongoose, so we manually remove them.

The next step is to have a running mongodb database. The easiest way to do this is using the following docker command:

```bash
docker run -d -p 27017:27017 --name mongodb mongo
```

So let's now try to start this server. We ask copilot chat to tell us how we need to do this:

````markdown
Tell me how to start the server. The server should auto reload changes.
````

The response is clear so we can do exactly as it says.

````markdown
To start the server with auto-reloading on changes, you can use a tool like `nodemon` which will watch your files and restart the server whenever a file changes.

First, you need to install `nodemon` as a development dependency. You can do this by running the following command in your terminal:

```bash
npm install --save-dev nodemon
```

Then, you need to add a start script to your `package.json` file that uses `nodemon` to run your server file. Assuming your server file is `src/server.ts`, you can add the following script:

```json
"scripts": {
  "start": "nodemon --watch 'src/**/*.ts' --exec 'ts-node' src/server.ts"
}
```

This script tells `nodemon` to watch all `.ts` files in the `src` directory and its subdirectories, and to use `ts-node` to execute your `src/server.ts` file whenever a file changes.

Finally, you can start your server with the following command:

```bash
npm start
```

This will start your server and it will automatically restart whenever you make changes to any `.ts` file in the `src` directory or its subdirectories.
````

The command did not work on my machine, I had to remove all single quotes in the `"start"` script to make it work.
After this it complained about the missing `import './middleware/passport'` which we have of course not created yet, so we remove this line.

### Comment routes

Now that we have got our infrastructure ready, lets implement the comment routes. 
We have documented the database and the api, so we can use these documents as input, so we provide `docs/readme.md`, `docs/server.md`, `docs/database/comment.md` and `docs/api/comment.yaml` (enclosed in a ```yaml snippet) to a new chat window and add the following prompt:

````markdown
Implement the mongoose schema and interface for comment. Include indices.
````

The response is a step by step description, followed by the file we can save to `src/models/Comment.ts`.

````typescript
import mongoose, { Document, Schema } from 'mongoose';

// Define the Comment schema
const CommentSchema = new Schema({
  issueId: { type: Number, required: true, index: true },
  userId: { type: Schema.Types.ObjectId, required: true, index: true },
  text: { type: String, required: true, maxlength: 500 },
  timestamp: { type: Date, default: Date.now },
});

// Define the Comment document interface
export interface IComment extends Document {
  issueId: number;
  userId: mongoose.Types.ObjectId;
  text: string;
  timestamp: Date;
}

// Create and export the Comment model
export const Comment = mongoose.model<IComment>('Comment', CommentSchema);
````

Now we start a new chat with the same files, add the newly created `src/models/Comment.ts` and add the following prompt:

````markdown
Give me the complete files with the implementation of this endpoint and the code to add to server.ts to register it.
````

The response tells us exactly what we need to do:

````markdown
To implement the endpoint for creating and fetching comments, you would need to create a new file in the `routes` directory. Let's call it `comment.ts`. 

Here's the code for `comment.ts`:

```typescript
import express from 'express';
import { body, validationResult } from 'express-validator';
import { Comment, IComment } from '../models/Comment';

const router = express.Router();

// Validation middleware for creating a new comment
const commentValidator = [
  body('issueId').isInt(),
  body('userId').isMongoId(),
  body('text').isLength({ max: 500 }),
];

router.post('/api/comment', commentValidator, async (req, res) => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    return res.status(400).json({ errors: errors.array() });
  }

  const { issueId, userId, text } = req.body;
  const comment: IComment = new Comment({ issueId, userId, text });

  await comment.save();

  res.status(201).json(comment);
});

router.get('/api/comment', async (req, res) => {
  const { issueId } = req.query;

  if (!issueId) {
    return res.status(400).json({ error: 'issueId query parameter is required' });
  }

  const comments = await Comment.find({ issueId });

  res.json(comments);
});

export default router;
```

Then, you would need to import this router in your `server.ts` file and use it:

```typescript
import express from 'express';
import commentRouter from './routes/comment';

const app = express();

app.use(express.json());
app.use(commentRouter);

// other middleware and routes...

app.listen(3000, () => {
  console.log('Server is running on port 3000');
});
```

This code creates two endpoints: `POST /api/comment` for creating a new comment and `GET /api/comment` for fetching comments for a specific issue. The `POST /api/comment` endpoint uses express-validator to validate the request body.
````

After verifying that /api/comment?issueId=1 returns the empty array we expected, we move on to the issue model and routes.
The model is generated using the same technique. We start a new chat window, add the files `docs/readme.md`, `docs/server.md`, `docs/database/issue.md` and `docs/api/issue.yaml` (enclosed in a ```yaml snippet) and add the following prompt:

````markdown
Implement the mongoose schema and interface for issue. Include indices. end every line of code with //NEWLINE
````
Copilot chat complained that the code it generated matched publicly available code and blocked the output, so I could not copy it.
Adding the //NEWLINE instruction nicely circumvented this problem ðŸ¤« and created the following code:

````markdown
Here is the TypeScript code to implement the Mongoose schema and interface for the Issue document. This code includes custom indices for the `_id`, `creatorId`, and `assigneeId` fields.

```typescript
import mongoose, { Document, Schema } from 'mongoose';

// Define the Issue interface
export interface IIssue extends Document {
  _id: number;
  title: string;
  description: string;
  status: string;
  creatorId: mongoose.Types.ObjectId;
  assigneeId: mongoose.Types.ObjectId;
}

// Define the Issue schema
const IssueSchema = new Schema<IIssue>({
  _id: { type: Number, required: true },  //NEWLINE
  title: { type: String, required: true, maxlength: 100 },  //NEWLINE
  description: { type: String, required: true },  //NEWLINE
  status: { type: String, required: true, enum: ['Open', 'In Progress', 'Closed'] },  //NEWLINE
  creatorId: { type: mongoose.Types.ObjectId, required: true, ref: 'User' },  //NEWLINE
  assigneeId: { type: mongoose.Types.ObjectId, ref: 'User' }  //NEWLINE
});

// Define the custom indices
IssueSchema.index({ _id: 1 });  //NEWLINE
IssueSchema.index({ creatorId: 1 });  //NEWLINE
IssueSchema.index({ assigneeId: 1 });  //NEWLINE

// Export the Issue model
export const Issue = mongoose.model<IIssue>('Issue', IssueSchema);  //NEWLINE
```
````
I had to replace the `type: mongoose.Types.ObjectId` with `type: Schema.Types.ObjectId` to make the code compile,
but that was all.

For creating the issue route, we need to supply the files `docs/readme.md`, `docs/server.md`, `docs/database/issue.md`, 
`docs/database/issue-id.md`, `docs/api/issue.yaml` and the newly generated `src/models/Issue.ts` (enclosed in a ```ts snippet)

When I attempted to create the implementation in a single prompt, copilot chat kept leaving out important bits.
This means the task is too complex and we need to help copilot chat by splitting it up into smaller tasks. 
I used the following 3 prompts to get the desired end result.

```markdown
Describe every endpoint with each parameter and tell in a few lines of pseudocode how to use mongodb to get the specified response and changes to the database. Include instructions how to determine the right _id when creating a new issue.
```

```markdown
Implement the complete implementation of this endpoint
```

```markdown
Add request validation for every route.
```

Then this end result came out:

````typescript
import express from 'express';
import { body, param, query, validationResult } from 'express-validator';
import { Issue, IIssue } from './models/Issue';
import mongoose from 'mongoose';

const router = express.Router();

// MongoDB connection
mongoose.connect('mongodb://localhost:27017/issue_management', { useNewUrlParser: true, useUnifiedTopology: true });

// Function to get the next issue ID
async function getNextIssueId() {
    const counter = await mongoose.connection.db.collection('counters').findOneAndUpdate(
        { _id: 'issue_id' },
        { $inc: { seq: 1 } },
        { returnOriginal: false }
    );
    return counter.value.seq;
}

// GET /api/issue
router.get('/api/issue', [
    query('title').optional().isString().withMessage('Title must be a string'),
    query('status').optional().isIn(['Open', 'In Progress', 'Closed']).withMessage('Invalid status'),
    query('assigneeId').optional().isMongoId().withMessage('Invalid assignee ID')
], async (req, res) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
        return res.status(400).json({ errors: errors.array() });
    }

    const filter: Partial<IIssue> = {};
    if (req.query.title) filter.title = req.query.title as string;
    if (req.query.status) filter.status = req.query.status as string;
    if (req.query.assigneeId) filter.assigneeId = new mongoose.Types.ObjectId(req.query.assigneeId as string);
    const issues = await Issue.find(filter);
    res.json(issues);
});

// POST /api/issue
router.post('/api/issue', [
    body('title').isString().withMessage('Title must be a string'),
    body('description').isString().withMessage('Description must be a string'),
    body('status').optional().isIn(['Open', 'In Progress', 'Closed']).withMessage('Invalid status'),
    body('creatorId').isMongoId().withMessage('Invalid creator ID'),
    body('assigneeId').optional().isMongoId().withMessage('Invalid assignee ID')
], async (req, res) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
        return res.status(400).json({ errors: errors.array() });
    }

    const _id = await getNextIssueId();
    const issue = new Issue({
        _id,
        title: req.body.title,
        description: req.body.description,
        status: req.body.status || 'Open',
        creatorId: req.body.creatorId,
        assigneeId: req.body.assigneeId
    });
    await issue.save();
    res.status(201).json(issue);
});

// GET /api/issue/{id}
router.get('/api/issue/:id', [
    param('id').isInt().withMessage('ID must be an integer')
], async (req, res) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
        return res.status(400).json({ errors: errors.array() });
    }

    const issue = await Issue.findById(req.params.id);
    if (!issue) return res.status(404).send('Issue not found');
    res.json(issue);
});

// PUT /api/issue/{id}
router.put('/api/issue/:id', [
    param('id').isInt().withMessage('ID must be an integer'),
    body('title').optional().isString().withMessage('Title must be a string'),
    body('description').optional().isString().withMessage('Description must be a string'),
    body('status').optional().isIn(['Open', 'In Progress', 'Closed']).withMessage('Invalid status'),
    body('assigneeId').optional().isMongoId().withMessage('Invalid assignee ID')
], async (req, res) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
        return res.status(400).json({ errors: errors.array() });
    }

    const update: Partial<IIssue> = {};
    if (req.body.title) update.title = req.body.title;
    if (req.body.description) update.description = req.body.description;
    if (req.body.status) update.status = req.body.status;
    if (req.body.assigneeId) update.assigneeId = req.body.assigneeId;
    const issue = await Issue.findByIdAndUpdate(req.params.id, update, { new: true });
    if (!issue) return res.status(404).send('Issue not found');
    res.json(issue);
});

export default router;
````
I had to remove the `mongoose.connect` statement and I had to fix some Typescript issues by using `any`, but then the code actually seems to work.
Before moving on to the client we add some demo data to the database. We let copilot chat generate the code for this. In the following prompt we provide `docs/server.md`, `docs/database/comment.md`, `docs/database/issue.md`, `src/models/Comment.ts` and `src/models/Issue.ts` and add the following prompt:

````markdown
Create a Typescript script that adds 2 issues containing 2 comments each to the database using the mongoose schemas above. Hardcode all user ids with the same value for now. Make realistic issues about a fictional government tax application web application.
````

I have omitted the result here, but after fixing a few Typescript issues, the script worked as expected and added the demo data to the database.

## Phase 3: The client

Before starting to generate the client, we need to decide which tools and libraries we want to use.
If you want to experiment with different technologies, you can checkout the `server` branch and start from there.
First of all, do we need a developer friendly framework when copilot chat writes all the code for us?
In this experiment we try to keep things as simple as possible, but according to our philosoply,
we must still be able to split up everything into small files. 
So I choose `htmx` as a simple library with the ability to load partial pages, 
while still being close to the plain HTML that copilot chat is famillair with.
For the CSS framework I experimented with both `bootstrap` and `tailwind`, 
but it turns out that copilot chat creates a nicer interface out of the box using `Bulma`.
I wrote down these decisions in the document `docs/client.md`.

````markdown
# Client

Files served to the client are in the public/ folder. All page urls end with .html 

We use static html files to create the frontend, 
styled using Bulma css and use vanilla javascript to load json data from the apis.
We also use htmx to split up the html into smaller components. 
This is done using the `hx-get` and `hx-trigger="load"` attribute.
Common elements like the user-menu can be found in the public/partials/ folder.
All pages include a consistent navbar.
````

The next step is to create a sitemap to describe the urls for our web application.
This is done by providing `specifications/readme.md`, `docs/client.md` and all `specification/pages/*.md` files and adding the following prompt:

````markdown
You are writing technical documentation for our web application to use as reference. You create short concise markdown documents. Create a short "Sitemap" document that contains a list of the html files that we need to fulfill these usecases and specify query-string parameters if applicable. We need it to create the navigation between pages.
````

The response is then added to `docs/client.md` for our next promts.

````markdown
# Sitemap

Here is a list of the HTML files that we need to fulfill the use cases. Each file corresponds to a specific page in the web application.

1. **index.html**: The home page of the application. No query-string parameters.

2. **issue-list.html**: The page that displays a list of all issues. Query-string parameters:
    - `search`: The search query to filter issues by title or description.
    - `status`: The status to filter issues by (Open, In Progress, Closed).
    - `assignedTo`: The user to filter issues by who they are assigned to.

3. **issue-details.html**: The page that displays the details of a specific issue. Query-string parameters:
    - `id`: The ID of the issue to display.

4. **create-issue.html**: The page that allows users to create a new issue. No query-string parameters.

5. **edit-issue.html**: The page that allows users to edit an existing issue. Query-string parameters:
    - `id`: The ID of the issue to edit.

6. **user-profile.html**: The page that displays the profile of a specific user. Query-string parameters:
    - `username`: The username of the user to display.

7. **login.html**: The page that allows users to log in. No query-string parameters.

8. **register.html**: The page that allows users to register a new account. No query-string parameters.

Please note that the `id` and `username` parameters should be properly URL-encoded to ensure that they can be correctly interpreted by the server.
````

Now all we need before creating our first page is a template. We use the following prompt to generate it, while providing only client.md:
  
````markdown
Create a blank plain template.html page that can be used as a starting point for pages like create-issue.html. 
It includes a navbar with a home link and a lazy loaded user menu. 
There is one placeholder where the main page content can be placed. please make the navbar stand out.
````

The response is then added to `public/template.html` for our next promts.

````html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Template Page</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/bulma/0.9.3/css/bulma.min.css">
</head>
<body>
    <nav class="navbar is-primary" role="navigation" aria-label="main navigation">
        <div class="navbar-brand">
            <a class="navbar-item" href="index.html">
                Home
            </a>
        </div>

        <div class="navbar-menu">
            <div class="navbar-end">
                <div hx-get="partials/user-menu.html" hx-trigger="load" class="navbar-item">
                    <!-- User menu will be loaded here -->
                </div>
            </div>
        </div>
    </nav>

    <main>
        <!-- Main content goes here -->
    </main>

    <script src="https://unpkg.com/htmx.org@1.6.1"></script>
</body>
</html>
````

This template is looks ok, so let's start by creating the `create-issue.html` page.
We start a new chat window, add the files `docs/client.md`, `public/template.html` (in an html snippet), `docs/api/issue.yml` (in a yaml snippet), `specifications/pages/create-issue.md` and add the following prompt:

````markdown
create the new-issue.html page. it contains inline javascript for the client side logic and interacts with the server using /api.
````

The response is actually pretty good, except that error handling is not implemented, 
but we did not specify how to handle errors in `docs/client.md`.

````html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Create New Issue</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/bulma/0.9.3/css/bulma.min.css">
</head>
<body>
    <nav class="navbar is-primary" role="navigation" aria-label="main navigation">
        <div class="navbar-brand">
            <a class="navbar-item" href="index.html">
                Home
            </a>
        </div>

        <div class="navbar-menu">
            <div class="navbar-end">
                <div hx-get="partials/user-menu.html" hx-trigger="load" class="navbar-item">
                    <!-- User menu will be loaded here -->
                </div>
            </div>
        </div>
    </nav>

    <main>
        <section class="section">
            <div class="container">
                <form id="create-issue-form">
                    <div class="field">
                        <label class="label" for="title">Title</label>
                        <div class="control">
                            <input class="input" type="text" id="title" name="title" required maxlength="100">
                        </div>
                    </div>

                    <div class="field">
                        <label class="label" for="description">Description</label>
                        <div class="control">
                            <textarea class="textarea" id="description" name="description" required></textarea>
                        </div>
                    </div>

                    <div class="field is-grouped">
                        <div class="control">
                            <button type="submit" class="button is-link">Submit</button>
                        </div>
                        <div class="control">
                            <button type="button" class="button is-link is-light" onclick="window.history.back()">Cancel</button>
                        </div>
                    </div>
                </form>
            </div>
        </section>
    </main>

    <script src="https://unpkg.com/htmx.org@1.6.1"></script>
    <script>
        document.getElementById('create-issue-form').addEventListener('submit', async function(event) {
            event.preventDefault();

            const title = document.getElementById('title').value;
            const description = document.getElementById('description').value;

            const response = await fetch('/api/issue', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ title, description })
            });

            if (response.ok) {
                window.location.href = 'issue-list.html';
            } else {
                // Handle error
            }
        });
    </script>
</body>
</html>
````

Submitting the form now fails, because there is no user logged in yet, so we comment out the validation in `routes/issue.ts` and make remove the required from the `creatorId`. The next problem we encounterd is the line `return counter.seq;` which had to be `return counter.seq;`.
After fixing this, the create-page works ðŸ¥³.

We continue by creating the `issue-list.html` page. We start a new chat window, add the files `docs/client.md`, `public/template.html` (in an html snippet), `docs/api/issue.yml` (in a yaml snippet), `specifications/pages/issue-list.md` and add the following prompt:

````markdown
````

## Conclusions

From what we have seen thusfar, we expect copilot chat can complete the
rest of the web application without any new kind of problems, so I think it
is time to summarize what we have learned thusfar from this experiment.

First of all, github copilot is capable of much more than it currently advertises.
Currently, it is fully capable of creating a whole web application, 
--> Promotion to autopilot

but it still needs a software engineer to write promts and review the code. 
I am even afraid that without an experienced software engineer, the code will contain
bugs like race conditions and even security vulnerabilities.
To give one example, in the web application we just created, 
when we browse to `/api/comment?issueId=a`, the whole server crashes.

So how do we design our web applications to be able to use copilot chat as an autopilot?
From what we have seen thusfar...
Using copilot as an autopilot to write most of your code is absolutely doable,
although it requires more effort in terms of documentation and structuring the code.
I think the effort is definitely worth it, because software engineers can now
really be more productive and focus on the more interesting parts of the code.
Less own abstractions, more repeating yourself.

Explanation: experience, big accurate short-term memory, but no long-term memory.

## Future work

I am very excited about working with copilot chat and discovering the possibilities.
But my time is limited, so It is time for others to dive in. There is much left to be discovered,
so I am opening up this repository for public contributions. Feel free to make pull requests and
start discussions on the issues page. I am especially curious about:

 - What is a good format for the specifications, so for example we can express the UI better?
 - How well can copilot chat make unit tests and end-to-end tests based on the specifications?
 - What tools and libraries work well on the server?
 - What frameworks and css work well in the client?

Thanks for reading this blog all the way to the end, I was unable to make it any shorter, so I hope you found it interesting.
I hope to see you soon on the issues page.

## (Un)license

This is free and unencumbered software released into the public domain.

Anyone is free to copy, modify, publish, use, compile, sell, or
distribute this software, either in source code form or as a compiled
binary, for any purpose, commercial or non-commercial, and by any
means.

In jurisdictions that recognize copyright laws, the author or authors
of this software dedicate any and all copyright interest in the
software to the public domain. We make this dedication for the benefit
of the public at large and to the detriment of our heirs and
successors. We intend this dedication to be an overt act of
relinquishment in perpetuity of all present and future rights to this
software under copyright law.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.

For more information, please refer to <https://unlicense.org>

